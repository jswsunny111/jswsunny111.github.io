---
title: vue2与vue3项目写法注意
date: 2022-10-28 21:27:28
tags: 原生
category: Vue
---

#### 1. 执行入口

```
//vue2.x
import Vue from 'vue';
import App from './App.vue';
new Vue({
    el: '#app',
	router,
	store,
    render: (h) => h(App),
});
//vue3
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App)
app.mount('#app') // 挂载 app.use(store).use(router)...
```

#### 2. 路由挂载

```
//vue2.x
import Vue from 'vue';
import VueRouter from 'vue-router';
Vue.use(VueRouter);
import { ROUTER_BASEPATH,  } from '../utils/constant';
const createRouter = () =>
 new VueRouter({
        mode: 'history',
		base :'ROUTER_BASEPATH',
     ...
    });
const router = createRouter();
router.beforeEach...
router.addRoutes(menus);//addRoute
export default router;
//vue3 必须要使用vue-router(v4)

import { createRouter, createWebHashHistory,createWebHistory } from 'vue-router'
import { ROUTER_BASEPATH,  } from '../utils/constant';
//  创建router，new VueRouter使用createRouter()
//  路由模式mode 更换为对应api，createWebHashHistory()  createWebHistory() base在函数中传参
// <router-link>已经没有tag属性的，可以用custom和插槽实现自定义。
// 新增了几个组合API：useRoute/useRouter/useLink。
// Vue3中，只保留了 addRoute() 方法
const router = createRouter({ //
  history: createWebHistory(ROUTER_BASEPATH), // hash createWebHashHistory() 路由模式有相对应函数
  ...
})

```

#### 3. vue 生命周期

```
//vue3中api是需要手动引入到组件中使用
import {onMounted } from 'vue'
//vue2.x  ||   vue3
beforeCreate      => setup(data,method)
created           => setup
beforeMount       => onBeforeMount
Mounted           => onMounted
beforeUptate      => onBeforeUpdate
Updated           => onUpdated
beforeDestroy     => onBeforeUnmount
Destroyed         => onUnmounted
```

#### 4. 响应数据

vue2.x[Object.defineProprty](https://v2.cn.vuejs.org/v2/guide/reactivity.html) 与 vue3[porxy](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#how-reactivity-works-in-vue) 原理不做展开介绍

```
//vue2.x
vue.Observable
 data 中的数据，组件创建时候就会作于依赖收集响应值
 Vue.set
//vue3
import { reactive,ref,torefs,computed ,watch} from 'vue'
export default {
	setup() {
		const state = reactive({
			conut:0,
			value:1,
		})
	}
	const val = ref(11)
	//计算属性的使用
	const contVal = computed(() => val.value +1)
	// 监听
	watch(val,() => {
		console.log( 'val',val.value)
	})
	// 监听reactive值
	watch(state,(newVal,oldVal) => {
		...
	})
	// 监听reactive属性值
	const stopWatch = watch(() => state.value,(newVal,oldVal) => {
		...
	})
	// 在setup()函数内创建的watch监视，会在当前组件被销毁的时候自动停止。如果想要明确的停止某个监视，可以调用watch()函数的返回值即可
	stopWatch()
	return {
		...torefs(state)
	}
}

//toRefs(）一般配合reactive()和…一起使用
```

#### 1. 模板内 ref 使用

```

//vue2.x   this.$refs['xxx']就可以获取对应节点信息方便操作
<template>
    <div ref="box"></div>
</template>
this.$refs.box


//vue3
在vue3中使用组合式API的setup()方法的时候，可以使用新的函数ref()。
使用ref()函数创建DOM引用,需在onMounted中获取
<template>
    <div ref="box"></div>
</template>
setup(){
	onMounted(() => {
	   const box= ref(null)
	})
}
```

#### 3. 设置全局变量

```
//vue2.x
// ue2.x挂载全局是使用 Vue.prototype.$xxxx=xxx 的形式来挂载，然后通过 this.$xxx来获取挂载到全局的变量或者方法。
Vue.prototype.$http = () => {}
//vue3
// 这在 Vue 3 中，就等同于 config.globalProperties。这些 property 将被复制到应用中作为实例化组件的一部分。
const app = createApp({})
app.config.globalProperties.$http = () => {}
或者利用依赖注入的方式 Provide / Inject
可以将全局变量放在根组件的 provide 中，这样所有的组件都能使用到这个变量。
如果需要变量是响应式的，就需要在 provide 的时候使用 ref 或者 reactive 包装变量。
```

#### 3. vue 自定义指令 v-

```
// 差异不大，主要载体发生变化。vue2.x中 在Vue挂载 vue3在createApp构建app上 局部基本一致与setup平级
// 主要 指令的生命周期
bind—>beforeMount
inserted—>mounted
beforeUpdate （元素自身更新前调用）
update vue3中已删除（和updated基本相同，因此被移除，可使用updated代替）
componentUpdated—>updated
beforeUnmount（与组件生命周期相似，元素将要被移除之前调用）
unbind—>unmounted
//vue2.x
import Vue from 'vue';
// 全局
vue.directive('name',{
	....
})
//局部
directives:{
	name:{
		...
	}
}
//vue3
// 全局
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App)
app.directive('name',{
	....
})
//局部
export default {
	directives:{
		name:{
			...
		}
	},
	setup(){
	}
}
```
