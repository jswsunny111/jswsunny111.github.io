---
title: 防抖/节流
date: 2021-06-26 09:59:15
tags: 工具函数
category: JavaScript
---

## 前言

防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。例如：滚动滚动条事件 onscroll，窗口大小改变事件 onresize onclick 防击穿，在实时检查输入时，如果我们绑定 onkeyup 事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发等 这些应用场景 我们都可以用上。

### 防抖

周期内多次触发事件，周期时间内动作只会执行一次，我们只是用最后一次的操作结果。使用定义 timeout 再次触发就清除之前的时间，取消之前的操作动作。 类似于，打游戏时的法师吟唱效果，有其他操作就会打断施法动作。

```
/**
 * @desc 函数防抖
 * @param func (function) 函数
 * @param wait (number) 延迟执行毫秒数
 * @param immediate (boolean) true 表立即执行，false 表非立即执行
 */
function debounce(func, wait = 1000, immediate) {
    var timeout
    return function() {
        var context = this
        var args = arguments
        if (timeout) clearTimeout(timeout)
        if (immediate) {
            var callNow = !timeout
            timeout = setTimeout(function() {
                timeout = null
            }, wait)
            if (callNow) func.apply(context, args)
        } else {
            timeout = setTimeout(function() {
                func.apply(context, args)
            }, wait)
        }
    }
}

```

### 节流

连续高频触发事件时，动作会被定期执行，规定时间内，动作只执行一次，响应平滑。 类似于，打游戏时的普攻，无论我们点击再快，受到游戏数据影响，都只会规定的速度进行攻击

```
 * @desc 函数节流
 * @param func (function) 函数
 * @param wait (number) 延迟执行毫秒数
 */
function throttle(func, wait) {
    var timeout;
    return function () {
        var context = this;
        var args = arguments;
        if (!timeout) {
            timeout = setTimeout(function () {
                timeout = null;
                func.apply(context, args)
            }, wait)
        }

    }
}
```
