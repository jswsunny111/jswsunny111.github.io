---
title: 数据原理2
date: 2021-08-15 21:27:28
tags: Vue
category: Vue
---

## 数据驱动模型

1. 获得模板， 模板中由‘坑’
2. 利用 Vue 构造函数中所提供的数据来"填坑"，得到可以再页面中显示的"标签"
3. 将标签替换页面中原来有坑的位置

## 模拟 vue 数据驱动

-   简化版本，没有考虑很多 Vue 实例的方法 指令等 只实现最基本的 DOM => virtualDOM => DOM 转换过程

*   效果图
    ![转换为虚拟DOM](/img/DOM1.png)
    ![虚拟DOM转换为真实DOM](/img/DOM2.png)
*   代码块

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root">
        <div>hello1</div>
        <div title="hello2" class="aa">hello2</div>
        <div>hello3</div>
        <div>hello4</div>
        <ul>
            <li id="li1" title="111">li1</li>
            <li>li2</li>
            <li>li3</li>
        </ul>
    </div>
    <script>
        //为什么使用virtualDom?
        //首先由于真实DOM操作太浪费性能，使用虚拟DOM 经过计算存储缓存中 后直接插入到真实DOM中 ，这样大大节约了开销

        /** 定义
         *  <div></div> => { tag: 'div'}
         *  文本节点 张三 => { tag: undefind, value: '张三'}
         *  <div title="1" class="aa" > <span>11</span></div> => { tag: 'div', data:{title: '1', class: 'aa'}, children:[{tag:'span',children:[{tag:'undefind',value:'11'}],}]}
         */
         /** 声明一个虚拟DOM 类 */
        class VNode {
            constructor(tag, data, value, type) {
                this.tag = tag && tag.toLowerCase();
                this.data = data;
                this.value = value;
                this.type = type;
                this.children = [];
            }
            /** 追加子节点 */
            appebdChild(vnode) {
                this.children.push(vnode)
            }
        }
        /** 使用递归 来遍历DOM 生成virtualDOM
         * VUE中使用的源码是栈结构， 使用栈存储 父元素来实现
         */
        function getVnode(node) {
            let nodeType = node.nodeType; //节点类型
            // console.log('传进', node);
            let _vnode = null;
            if (nodeType === 1) { //元素节点类型
                let nodeName = node.nodeName; //节点名称
                let attrs = node.attributes; //节点属性 为数组
                // console.log('节点名称', nodeName, '节点属性', attrs);
                let _attrsObj = {};
                for (let i = 0; i < attrs.length; i++) {
                    _attrsObj[attrs[i].nodeName] = attrs[i].nodeValue;
                }
                _vnode = new VNode(nodeName, _attrsObj, undefined, nodeType);
                // node 子元素
                let childNodes = node.childNodes; //获取当前元素的所有子元素
                for (let i = 0; i < childNodes.length; i++) {
                    _vnode.appebdChild(getVnode(childNodes[i])) //再次将子元素递归
                }
            } else if (nodeType === 3) { //文本节点类型
                _vnode = new VNode(undefined, undefined, node.nodeValue, node.nodeType)
            }
            // 将vnode返回
            return _vnode
        }
        /** 创建真实DOM */
        function parseVNode(vnode) {
            // 获取虚拟dom类型 文本节点创建文本 元素节点创建元素
            let type = vnode.type //type是 class VNode中声明的type
            let _node = null;
            if (type === 3) {
                return document.createTextNode(vnode.value); //文本节点只需传递value 值
            } else if (type == 1) {
                _node = document.createElement(vnode.tag); // 创建元素节点
                //添加数据
                let data = vnode.data;
                for (key in data) {
                    _node.setAttribute(key, data[key])
                }
                // 添加子元素
                let children = vnode.children;
                children.forEach(v => { // 每项都是虚拟DOM 递归再次调用
                    _node.appendChild(parseVNode(v))
                })
            }
            return _node
        }
        let root = document.querySelector('#root');
        console.log('真实root', root);
        let VNodeRoot = getVnode(root);
        console.log('转换为虚拟DOM', VNodeRoot);
        let root2 = parseVNode(VNodeRoot);
        console.log('虚转真root', root2);
    </script>

</body>

</html>
```

(笔记)
![BG图片](/img/1.jpg)
