---
title: 数据原理3
date: 2021-10-14 19:20:28
tags: Vue
category: Vue
---

## 数据驱动模型

## 模拟 vue 数据驱动

-   简化实现 VUE 真实 DOM => VNode => 数据+模板 => 真实 DOM => 页面

-   class VNode(虚拟 DOM 类)
-   getVnode (真实 DOM => 获取虚拟 DOM)
-   getValueByPath (处理 data 嵌套层数据)
-   combine (将获取真实的 DOM 带有{...} 的模板与数据结合)
-   parseVNode (虚拟 DOM 生成真实 DOM)
-   JGVue (VUE 构造函数)
-   mountComponent (VUE 执行 挂载函数) 方便后期使用发布订阅模式
-   createRenderFn ( 返回一个 render 函数 带有缓存行为 闭包)
-   update (VUE 更新阶段 diff 算法省略 渲染到页面中)

*   示例图
    ![带槽的dom](/img/带槽的dom.png)
    ![数据与虚拟DOM结合后](/img/数据与虚拟DOM结合后.png)
*   代码块

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root">
        <div>{{name}}</div>
        <div title="hello2" class="aa">hello2</div>
        <div>{{age}}</div>
        <div>{{gender}}</div>
        <ul>
            <li id="li1" title="111">li1</li>
            <li>li2</li>
            <li>li3</li>
        </ul>
    </div>
    <script>
        /** 生成虚拟DOM  */
        class VNode {
            constructor(tag, data, value, type) {
                this.tag = tag && tag.toLowerCase();
                this.data = data;
                this.value = value;
                this.type = type;
                this.children = [];
            }
            /** 追加子节点 */
            appebdChild(vnode) {
                this.children.push(vnode)
            }
        }

        function getVnode(node) {
            let nodeType = node.nodeType; //节点类型
            let _vnode = null;
            if (nodeType === 1) { //元素节点类型
                let nodeName = node.nodeName; //节点名称
                let attrs = node.attributes; //节点属性 为数组
                // console.log('节点名称', nodeName, '节点属性', attrs);
                let _attrsObj = {};
                for (let i = 0; i < attrs.length; i++) {
                    _attrsObj[attrs[i].nodeName] = attrs[i].nodeValue;

                }
                _vnode = new VNode(nodeName, _attrsObj, undefined, nodeType);
                // node 子元素
                let childNodes = node.childNodes; //获取当前元素的所有子元素
                for (let i = 0; i < childNodes.length; i++) {
                    _vnode.appebdChild(getVnode(childNodes[i])) //再次将子元素递归
                }
            } else if (nodeType === 3) { //文本节点类型
                _vnode = new VNode(undefined, undefined, node.nodeValue, node.nodeType)
            }
            // 将vnode返回
            return _vnode
        }
        /** 根据路径 处理数据 */
        function getValueByPath(obj, path) {
            let paths = path.split('.');
            let res = obj;
            let prop;
            while (prop = paths.shift()) {
                res = res[prop];
            }
            return res;
        }
        let Rkuohao = /\{\{(.+?)\}\}/g;
        /** 将带有坑的vnode 与数据结合 */
        function combine(vnode, data) {
            let _type = vnode.type;
            let _data = vnode.data;
            let _value = vnode.value;
            let _tag = vnode.tag;
            let _children = vnode.children;
            let _vnode = null;
            if (_type == 3) { //文本节点
                _value = _value.replace(Rkuohao, function (_, g) {
                    return getValueByPath(data, g.trim())
                })
                _vnode = new VNode(_tag, _data, _value, _type)
            } else if (_type == 1) { //元素节点
                _vnode = new VNode(_tag, _data, _value, _type)
                _children.forEach(v => _vnode.appebdChild(combine(v, data)))
            }
            return _vnode;
        }

        /** 创建真实DOM */
        function parseVNode(vnode) {
            // 获取虚拟dom类型 文本节点创建文本 元素节点创建元素
            let type = vnode.type //type是 class VNode中声明的type
            let _node = null;
            if (type === 3) {
                return document.createTextNode(vnode.value); //文本节点只需传递value 值
            } else if (type == 1) {
                _node = document.createElement(vnode.tag); // 创建元素节点
                //添加数据
                let data = vnode.data;
                for (key in data) {
                    _node.setAttribute(key, data[key])
                }
                // 添加子元素
                let children = vnode.children;
                children.forEach(v => { // 每项都是虚拟DOM 递归再次调用
                    _node.appendChild(parseVNode(v))
                })
            }
            return _node
        }

        function JGVue(options) {
            this._data = options.data;

            let elm = document.querySelector(options.el); // vue中是字符串 （我们使用虚拟DOM）
            this._template = elm;
            this._parent = elm.parentNode; //获取父元素
            this.mount(); //挂载
        }

        JGVue.prototype.mount = function () {
            // 需要提供一个render 方法生成虚拟DOM
            this.render = this.createRenderFn()

            this.mountComponent();
        }

        JGVue.prototype.mountComponent = function () {

            // 执行 mountComponent
            let mount = () => {
                this.update(this.render());
            }
            mount.call(this)
            // this.update(this.render())// 使用发布订阅 交给watchr 来完成
        }

        /**
         * 生成render函数 方法 缓存抽象语法树（我们使用虚拟DOM）
         * 在页面中的DOM 和虚拟DOM 是一一对应关系
         * 先有AST 和数据生成VNode (新，render)
         * 将旧的VNode 和新的VNode 比较（diff）更新（updata）
         */
        JGVue.prototype.createRenderFn = function () {

            let ast = getVnode(this._template)
            // vue 将AST + Data => VNode
            return function render() {
                // debugger;
                let temp = combine(ast, this._data);
                return temp;
            }
        }
        // 虚拟DOM 渲染到页面中 diff算法
        JGVue.prototype.update = function (vnode) {
            // 简化，直接生成 HTML DOM replaceChild 到页面中
            let realDom = parseVNode(vnode);
            // debugger;
            console.log(this._parent);
            //   这个地方没有使用算法 直接替换
            this._parent.replaceChild(realDom, document.querySelector('#root'))
        }

        let app = new JGVue({
            el: "#root",
            data: {
                name: '张三',
                age: '16',
                gender: '男',
            }
        })
    </script>

</body>

</html>
```

(笔记)
![BG图片](/img/1.jpg)
