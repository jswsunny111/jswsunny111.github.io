---
title: 数据原理1
date: 2021-10-12 21:03:28
tags: Vue
category: Vue
---

## 数据驱动模型

1. 获得模板， 模板中由‘坑’
2. 利用 Vue 构造函数中所提供的数据来"填坑"，得到可以再页面中显示的"标签"
3. 将标签替换页面中原来有坑的位置

## 模拟 vue 数据驱动

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root">
        <p>{{name}}</p>
        <p>{{msg}}</p>
    </div>
    <script>
        // 步骤拆解
        // 1. 拿到模板
        // 2. 拿到数据
        // 3. 将数据与模板结合 得到的时 HTML (DOM元素)
        // 4. 放到页面中

        //  1 获取模板
        let tmpNode = document.querySelector('#root'); //获取元素
        // 2. 获取数据
        let data = {
            name: '这是名字',
            msg: '这是消息',
        }
        // 3. 将数据放到模板中、
        let Rkuohao = /\{\{(.+?)\}\}/g;
        // vue 源码中是 将真是DOM -> 字符串模板 -> VDOM -> 真实DOM
        //  下面使用递归的方式
        function compiler(template, data) {
            let childNodes = template.childNodes; //取出子元素
            console.log('打印node 节点', childNodes);
            for (let i = 0; i < childNodes.length; i++) {
                let type = childNodes[i].nodeType // 十几种类型  1 元素 2 文本

                if (type == 3) {
                    let txt = childNodes[i].nodeValue; //该属性只有文本才有意义
                    // 匹配花括号
                    txt = txt.replace(Rkuohao, function (_, g) {
                        // g代表每次匹配的值
                        // replace 使用匹配一次 函数会调用一次
                        let key = g.trim()
                        let value = data[key]
                        return value

                    })
                    // 注意 TXT和DOM是没有关系的 所以将其替换掉
                    childNodes[i].nodeValue = txt

                } else if (type == 1) {
                    //   元素,考虑它有没有子元素 是否需要将其子元素进行 判断是否需要插值
                    compiler(childNodes[i], data)
                }
            }
        }
        // 克隆node节点 如果使用获取的话，是引用类型 会直接转换 再次就是获取的不是模板了
        let cloneNode = tmpNode.cloneNode(true)
        console.log('原始Node', tmpNode);
        compiler(cloneNode, data)
        console.log('处理后的Node', cloneNode);
        // 4 将clone 的节点插入html
        root.parentNode.replaceChild(cloneNode, root)
    </script>

</body>

</html>
```

-   以上简单实现 但与实际很大的差异
-   vue 是虚拟 DOM
-   局限性 data 数据 实际业务中会用到 a.b.c 层次型数据
-   操作指令 代码没有整合

### 优化

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root">
        <p>{{name.firstName}}{{name.lastName}}</p>
        <p>{{msg}}</p>
    </div>
    <script>
        // 构造函数
        let Rkuohao = /\{\{(.+?)\}\}/g;
        /** 获取data值对应 */
        function getValueByPath(obj, path) {
            let paths = path.split('.');
            let res = obj;
            let prop;
            while (prop = paths.shift()) {
                res = res[prop];
            }
            return res;
        }
        /** 递归 获取DOM 与data 的结合*/
        function compiler(template, data) {
            let childNodes = template.childNodes; //取出子元素
            for (let i = 0; i < childNodes.length; i++) {
                let type = childNodes[i].nodeType // 十几种类型  1 元素 2 文本
                if (type == 3) {
                    let txt = childNodes[i].nodeValue; //该属性只有文本才有意义
                    // 匹配花括号
                    txt = txt.replace(Rkuohao, function (_, g) {
                        // g代表每次匹配的值
                        // replace 使用匹配一次 函数会调用一次
                        let key = g.trim()
                        let value = getValueByPath(data, key)
                        return value
                    })
                    // 注意 TXT和DOM是没有关系的 所以将其替换掉
                    childNodes[i].nodeValue = txt

                } else if (type == 1) {
                    //   元素,考虑它有没有子元素 是否需要将其子元素进行 判断是否需要插值
                    compiler(childNodes[i], data)
                }
            }
        }
        function JGvue(options) {
            // _ 开头的是内部数据 $开头的是只读数据
            this._data = options.data;
            this._el = options.el;
            // 准备模板
            this.$el = this._templateDOM = document.querySelector(this._el);
            this._parent = this._templateDOM.parentNode;
            // 渲染
            this.render();
        };
        // 向原型添加方法
        /** 将模板和数据结合进行渲染到HTML页面之中 */
        JGvue.prototype.render = function () {
            this.compiler()
        };
        /** 将模板和数据结合得到真正的DOM*/
        JGvue.prototype.compiler = function () {
            let realHTMLDOM = this._templateDOM.cloneNode(true); //获取克隆的准DOM
            //将DOM 和 数据结合
            compiler(realHTMLDOM, this._data)
            this.updata(realHTMLDOM);
        };

        /** 更新，将DOM 放到页面之中*/
        JGvue.prototype.updata = function (real) {
            this._parent.replaceChild(real, document.querySelector("#root"));
        };


        //    使用方式
        let app = new JGvue({
            el: "#root",
            data: {

                msg: '信息啊',
                name: {
                    firstName: '张',
                    lastName: '三',
                },
            }
        })
    </script>
</body>
</html>
```

(笔记)
![BG图片](/img/1.jpg)
