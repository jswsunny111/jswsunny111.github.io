---
title: Vue响应数据原理
date: 2021-07-26 21:27:28
tags: Vue
category: Vue
---

## [响应式原理（Vue.2x）](https://cn.vuejs.org/v2/guide/reactivity.html)

官网上介绍了， Vue2.x 版本数据绑定原理其主要于使用[Object.defineProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)的方法，对数据进行了`getter/setter`数据劫持。

### Object.defineProperty()

> Object.defineProperty 需要三个参数（object , propName , descriptor）

-   object 对象 => 添加的对象
-   propName 属性名 => 要加的属性的名字 【类型：String】
-   descriptor 属性描述 => 加的这个属性值【类型：Object】

```
var message = 'hello world';
const data = {};
Object.defineProperty(data, 'message', {
   get() {
       return message;
   },
   set(newVal) {
       message = newVal;
   }
});
data.message // 'hello world'
data.message = 'test' // 'test'
```

## Vue 中实现数据劫持过程

> 经典的例子

```
const data = {
    name: '你不知道的VUE',
    age: 25,
    info: {
        address: '北京'
    },
    numbers: [1, 2, 3, 4]
};
function observerObject(target, name, value) {
    if (typeof value === 'object' || Array.isArray(target)) {
        observer(value);
    }
    Object.defineProperty(target, name, {
        get() {
            return value;
        },
        set(newVal) {
            if (newVal !== value) {
                if (typeof value === 'object' || Array.isArray(value)) {
                    observer(value);
                }
                value = newVal;
            }
            renderView();
        }
    });
}
function observer(target) {
    if (typeof target !== 'object' || !target) {
        return target;
    }
    for (const key in target) {
        if (target.hasOwnProperty(key)) {
            const value = target[key];
            observerObject(target, key, value);
        }
    }
}
observer(data);
```

遍历这个 data 对象，对每一个属性都使用 observerObject 方法进行数据劫持。

observerObject 主要做的就是使用 Object.defineProperty 去监听传入的属性，如果 target 是一个对象的话，就递归执行 observer，确保 data 中所有的对象中的所以属性都能够被监听到。当我们 set 的时候，去执行 renderView（执行视图渲染相关逻辑）。

### Object.defineProperty 局限性

1.  递归遍历所有的对象的属性，这样如果我们数据层级比较深的话，是一件很耗费性能的事情
2.  只能应用在对象上，不能用于数组
3.  只能够监听定义时的属性，不能监听新加的属性，这也就是为什么在 vue 中要使用 Vue.set/vue.detele

## [Proxy(Vue3)](https://v3.cn.vuejs.org/guide/reactivity.html#proxy-vs-%E5%8E%9F%E5%A7%8B%E6%A0%87%E8%AF%86)

-   使用了 proxy 去实现对象的监听，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

-   Proxy 对拦截操作多达 13 种，所以在这 13 中操作中，我们可以自定义很多逻辑。Proxy 的出现，其实就是为了扩展对象的能力。

### [proxy MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

`new Proxy(target, handler)`
target: 拦截的目标对象
handler：定义拦截的方法

-   handler.apply
-   handler.construct 拦截构造函数调用 new Example（）
-   handler.difineProperty
-   handler.get 拦截对象属性的读取 obj.name
-   handler.set 拦截对象属性的设置 obj.name = '前端的自我修养'
-   handler.getOwnPropertyDwscriptor
-   handler.has
-   handler.ownKeys 拦截 Object.keys for in 等
-   handler.setPrototypeOf
-   handler.isExtensible
-   handler.getPropertyOf
-   handler.preventExtensiions
-   handler.enumerate

### Refect

-   将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。
-   修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。
-   让 Object 操作都变成函数行为。比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。
-   Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的\* Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。

### 数据劫持相应

```
function observe(target) {
    if (typeof target !== 'object' || target == null) {
        return target;
    }
    const obseved = new Proxy(target, {
        get(target, key, receiver) {
           return observe(Reflect.get(target, key, receiver);)

        },
        set(target, key, value, receiver) {
            if (value === target[key]) {
                return true;
            }
            const ownKeys = Reflect.ownKeys(target);
              if (ownKeys.includes(key)) {
                console.log('旧属性');
            } else {
                console.log('新添加的属性');

           return Reflect.set(target, key, value, receiver);


        },
        deleteProperty(target, key) {
           return result  Reflect.deleteProperty(target, key);

        }
    });
    return obseved;
}
const data = {
    name: '你不知道的前端',
    age: 25,
    info: {
        city:'beijing'
    }，
    numbers: [1, 2, 3, 4]
};
const proxyData = observe(data
```

#### proxy 在实现数据劫持时，具有以下优点

-   proxy 可以直接监听数组的修改
-   proxy 可以直接监听属性的新增和删除
-   在实现深度监听的时候，只有在 data 对象的属性被访问的时候，才去对这个属性做监听处理，而不是一次性递归所有的。

> 内容便于自身理解，并非 vue 源码实现
> 部分内容转载于 知乎-[Vue 如何实现数据劫持](https://zhuanlan.zhihu.com/p/111591503)

![BG图片](/img/1.jpg)
